var Enums = require('./enums'),
    Event = require('./event'),
    md5 = require('MD5'),
    _ = require('./utils'),
    /**
     * Error messages
     * @type {Object}
     */
    errors = {
      exception: '[VoiceInsights ERROR] Unexpected Exception',
      intentFormat: '[VoiceInsights ERROR] Invalid intent passed in - must adhere to the standard Alexa intent format',
      sessionError: '[VoiceInsights ERROR]: You must provide a valid session object.',
      speechOutputFormat: '[VoiceInsights ERROR] Invalid speechOutput passed in - must adhere to the standard Alexa speechOutput format'
    },
    /**
     * Session event and payload data
     * @type {Object}
     */
    config = {},
    /**
     * Helper function to keep triggering events DRY
     * @param  {String}   type     String containing the event name
     * @param  {Object}   event    Voice Event object
     * @param  {Object}   payload  Object containing session, token, etc...
     * @param  {Function} callback Callback function to execute after event trigger
     * @return {Object}            The Voice instance
     */
    trigger = function(type, event, payload, callback){
      if(!event){
        event = new Event(type, payload);
      }

      var done = false;
      var data = null;

      try {
        event.send(function(response){
          data = response;
          done = true;
        });
      }catch(error){
        data = error;
        done = true;
        console.error(errors.exception, error);
      }

      require('deasync').loopWhile(function(){return !done;});

      if(_.isFunction(callback)){
        callback(data);
      }

      return Voice;
    };
/**
 * Voice constructor
 * @constructor
 * @param  {Object} session Object containing session metadata
 * @param  {String} token   String containing the unique app token
 * @return {Void}
 */
var Voice = function(session, token){
  if(!_.isObject(session)){
     console.error('[VoiceInsights ERROR]: You must provide a valid session object.');
  }

  if(!token || token && !token.length || token && !_.isString(token)){
    console.error('[VoiceInsights ERROR]: You must provide a valid token string.');
  }

  var uid = null;

  if(!session.user || !session.user.userId){
    console.error('[VoiceInsights ERROR]: A valid user ID must be provided, got null');
  }else{
    uid = md5(session.user.userId);
  }

  config = {
    session: session,
    token: token,
    uid: uid,
    payload: {
      app_token: token,
      user_hashed_id: uid,
      session_id: session.sessionId
    }
  };

};

_.extend(Voice, {
  /**
   * Fires the initialize event and executes the callback
   * @param  {Object} session Object containing session metadata
   * @param  {String} token   String containing the unique app token
   * @return {Void}
   */
  initialize: function(session, token){
    if(!session){
      console.error('[VoiceInsights ERROR]: You must provide a valid session object.');
      return Voice;
    }
    if(!config.session || session.new){
      var session = new Voice(session, token);
      return trigger(Enums.eventTypes.INITIALIZE, null, config.payload);
    } else {
      return Voice;
    }

  },

  /**
   * Fires the tag speech event and executes the callback
   * function with the speech output SSML + response
   * @param  {String}   intentName            The intent string
   * @param  {Object}   intentMetadata        Object containing intent metadata like slots
   * @param  {Function} callback              Callback function to execute
   * @return {Void}
   */
  track: function(intentName, intentMetadata, speechText, callback){
    var payload = {
      app_token: config.token,
      user_hashed_id: config.uid,
      session_id: config.session ? config.session.sessionId : null,
      intent: null,
      data: {
        metadata: null,
        speech: speechText
      }
    };

    if(!intentName){
       console.error(errors.intentFormat);
     }else{
       payload.intent = intentName;
       payload.data.metadata = intentMetadata
    }

    var event = new Event(Enums.eventTypes.SPEECH, payload);

    return trigger(Enums.eventTypes.SPEECH, event, payload, callback);
  }
});

module.exports = Voice;
